%tables were generated by using http://www.tablesgenerator.com
\documentclass[compress]{beamer}
\usetheme{Antibes}
\usecolortheme{dolphin}
\usefonttheme[onlymath]{serif}

\usepackage{amsmath}
\usepackage{mathcomp}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\graphicspath{{./images/}}
\usepackage{listings}
\usepackage{caption}
\usepackage{multirow}
\usepackage{url}
\usepackage[backend=biber,style=trad-abbrv]{biblatex}

\bibliography{literature}

\usepackage{tikz}
\usetikzlibrary{automata,positioning}

\title{Checking Equivalence of Nondeterministic Finite Automata}
\author{David Kofler}
\date{\today}
\institute{Master Seminar 2 \newline University of Innsbruck \newline Institute of Computer Science}


\begin{document}

\begin{frame}{}
	\maketitle
\end{frame}

\begin{frame}{}
	\tableofcontents
\end{frame}

\begin{frame}{Main Source}
  \fullcite{Bonchi:2013:CNE:2429069.2429124}
\end{frame}

\section{Introduction}



\begin{frame}{Applications}
  \begin{itemize}
    \item Model checking
    \item Compiler construction
    \item Testing microchips
    \item Homework/Exams: Did I/a student simplify a given automata correctly?
  \end{itemize}
\end{frame}

\begin{frame}{Complexity}
  \begin{itemize}
    \item For DFA: $\mathcal{O}(n \cdot \alpha(n))$ algorithm by Hopcroft and Karp (1971)
    \item For NFA: $\mathcal{O}(2^n)$ (PSPACE-complete)
  \end{itemize}
\end{frame}

\input{example_1}

\input{example_2_1}

\section{Algorithm}

\begin{frame}{Nondeterministic finite automata}
  \begin{block}{Definition}
    \begin{itemize}
      \item $N := (Q, \Sigma, o, \delta)$
      \item $Q$ and $\Sigma$ are finite sets
      \item $o : Q \to \{\emptyset, \{\epsilon\} \}$
      \item $\delta : Q \to \Sigma \to \mathcal{P}(Q)$
      \item $\mathcal{L} : Q \to \mathcal{P}(\Sigma^\ast)$
    \end{itemize}
  \end{block}
\end{frame}

\input{algorithm}

\section{Comparing NFAs}

\begin{frame}{Determinisation by powerset construction}
  \begin{figure}
    \begin{align*}
      o^\#(Q) &= \bigcup_{q \in Q} o(q)\\
      \delta^\#(Q, a) &= \bigcup_{q \in Q} \delta(q, a)
      %o^\#(X) = &\begin{cases}
      %    o(x)                    &\text{ if } X = \{x\}, x \in S\\
      %    \emptyset               &\text{ if } X = \emptyset\\
      %    o^\#(X_1) \cup o^(X_2)  &\text{ if } X = X_1 \cup X_2\\
      %  \end{cases}\\
      %\delta^\#(X, a) = &\begin{cases}
      %    \delta(x, a)                              &\text{ if } X =\{x\}, x \in S\\
      %    \emptyset                                 &\text{ if } X = \emptyset\\
      %    \delta^\#(X_1, a) \cup \delta^\#(X_2, a)  &\text{ if } X = X_1 \cup X_2\\
      %  \end{cases}
    \end{align*}
  \end{figure}

  \begin{block}{Determinised NFA}<2->
    We obtain the determinised automaton $N^\# = (\mathcal{P}(S), \Sigma, o^{\#}, d^{\#})$
      from the NFA $N = (S, \Sigma, o, \delta)$
  \end{block}
\end{frame}

\begin{frame}{Language equivalence of NFAs}
  \begin{block}{Bisimulations on sets of states}<1->
    \begin{itemize}
      \item Relation between sets of states: $R \subseteq \mathcal{P}(Q)^2$% \times \mathcal{P}(Q)$
      \item $R$ is bisimulation $\iff \forall Q_1, Q_2 \in \mathcal{P}(Q): $
        \begin{itemize}
          \item $o^\#(Q_1) = o^\#(Q_2)$, and
          \item $\forall a \in \Sigma: (\delta^\#(Q_1, a), \delta^\#(Q_2, a)) \in R$
        \end{itemize}
    \end{itemize}
  \end{block}

  \begin{block}{Language equivalence}<2->
    \begin{itemize}
      %\item $p \sim q \Leftrightarrow \mathcal{L}(\{p\}) = \mathcal{L}(\{q\})$
      \item
      Coinduction:\\
        $\mathcal{L}(P) = \mathcal{L}(Q) \iff \exists$ bisimulation $R: (P, Q) \in R$
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Contribution of Pous and Bonchi}
  \begin{itemize}
      \item<1-> $\textbf{(2.2)}\quad \textbf{if } \mathbf{(p', q') \in} \textbf{ R} \textbf{ then goto (2)}$
      \item<2-> $(p', q') \in R$ can be replaced by $(p', q') \in f(R)$
      \item<2-> $f$ has to be \textbf{compatible}
      \item<3-> Existing algorithms differ only by $f$
      \item<4-> There is a very effective choice of $f$ for NFAs
    \end{itemize}
\end{frame}

\begin{frame}{Compatible functions}
  \begin{itemize}
    \item<1-> Identity function
    \item<2-> Symmetric closure: $(q, p) \in R \Rightarrow (p, q) \in R$
    \item<3-> Equivalence closure:
      \begin{align*}
        \forall p: (p, p) \in R\\
        (p, q) \in R \Rightarrow (q, p) \in R\\
        (p, q) \in R \land (q, r) \in R \Rightarrow (p, r) \in R\\
      \end{align*}
    \item<4-> Congruence closure (for determinised NFAs):\\
        $(P_1, Q_1) \in R \land (P_2, Q_2) \in R \Rightarrow (P_1 \cup Q_2, P_2 \cup Q_2) \in R$
  \end{itemize}
\end{frame}

\input{example_2_2}

\begin{frame}{Data structure for congruence closure}
  \begin{block}{Hello}
    \begin{itemize}
        \item Binary decision diagrams
        \item Pous and Bonchi's approach: Set rewriting
        \item $(P, Q) \in c(R) \iff P \downarrow_R = Q \downarrow_R$
    \end{itemize}
  \end{block}
  \begin{figure}
    \input{example_set_rewriting}
  \end{figure}
\end{frame}

\begin{frame}{Set rewriting}
  \begin{itemize}
    \item Store only processed pairs and their normal forms
    \item View $R$ as set of rewrite rules:
      \begin{align*}
        \forall (P, Q) \in R: \quad&P \rightsquigarrow P \cup Q\\
                              &Q \rightsquigarrow P \cup Q\\
        \forall Q: P \rightsquigarrow P' \Rightarrow & P \cup Q \rightsquigarrow P' \cup Q
      \end{align*}
  \end{itemize}
\end{frame}

\section{Experimental Results}

\begin{frame}{Language equivalence - 50 states}
  \begin{figure}
    \input{experiment_equivalence_n_50}
  \end{figure}
\end{frame}

\begin{frame}{Language equivalence - 100 states}
  \begin{figure}
    \input{experiment_equivalence_n_100}
  \end{figure}
\end{frame}

\begin{frame}{Language equivalence - 1000 states}
  \begin{figure}
    \input{experiment_equivalence_n_1000}
  \end{figure}
\end{frame}

\begin{frame}{Language inclusion - Matches}
  \begin{figure}
    \input{experiment_inclusions_matches}
  \end{figure}
\end{frame}

\begin{frame}{Language inclusion - Mismatches}
  \begin{figure}
    \input{experiment_inclusions_mismatches}
  \end{figure}
\end{frame}

\section{Conclusion}

\begin{frame}{Main Takeaways}
  \begin{itemize}
    \item<1-> Naive algorithm, ACs, HK, HKC, and other variants can be uniformely
      presented by using coinductive techniques
    \item<2-> The AC algorithms perform surprisingly bad
      \begin{itemize}
        \item Maybe it is unfair to let \textbf{libvata} operate solely on string automata?
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{center}
    \huge{Questions \& Discussion}
  \end{center}
\end{frame}

\section*{Addendum}

\begin{frame}{Compatibility}
  \begin{block}{Progression}
    \begin{itemize}
      %\item $R, R' \subseteq S \times S$
      \item $R \rightarrowtail R' \iff \forall (x, y) \in R:$\\
        \begin{itemize}
          \item $o(x) = o(y)$, and
          \item $\forall a \in \Sigma: (\delta(x, a), \delta(y, a)) \in R'$
        \end{itemize}
      %\item $R \rightarrowtail R \Leftrightarrow R \text{ is bisimulation}$
    \end{itemize}
  \end{block}

  \begin{block}{Compatibility}
    $f : (S \times S) \to (S \times S)$ is compatible iff \\
    \begin{itemize}
      \item $f$ monotone: $\forall R: R \subseteq f(R)$, and
      \item $f$ preserves $\rightarrowtail$:
        $R \rightarrowtail R' \Rightarrow f(R) \rightarrowtail f(R')$
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
